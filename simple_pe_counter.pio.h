// ---------------------------------------------------------------- //
// This file is autogenerated by pioasm version 2.2.0; do not edit! //
// ---------------------------------------------------------------- //

#pragma once

#if !PICO_NO_HARDWARE
#include "hardware/pio.h"
#endif

extern volatile uint8_t column_scan_line;
extern volatile bool column_scan_line_updated;  // 更新フラグ追加
extern volatile uint8_t columnBits[15];
extern void driveAH_Direct(uint8_t bits);
extern volatile uint8_t bits; 

// グローバル変数
extern volatile uint32_t last_pe_time_us;  // 最後にPE信号を受信した時刻（マイクロ秒）
extern volatile bool pe_signal_active;

// リングバッファ
#define RING_BUFFER_SIZE 500
volatile uint16_t ring_buffer[RING_BUFFER_SIZE];
volatile uint16_t write_index = 0;
volatile bool buffer_full = false;

// ----------------- //
// simple_pe_counter //
// ----------------- //

#define simple_pe_counter_wrap_target 0
#define simple_pe_counter_wrap 2
#define simple_pe_counter_pio_version 0

static const uint16_t simple_pe_counter_program_instructions[] = {
            //     .wrap_target
    0x2020, //  0: wait   0 pin, 0
    0xc000, //  1: irq    nowait 0
    0x20a0, //  2: wait   1 pin, 0
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program simple_pe_counter_program = {
    .instructions = simple_pe_counter_program_instructions,
    .length = 3,
    .origin = -1,
    .pio_version = simple_pe_counter_pio_version,
#if PICO_PIO_VERSION > 0
    .used_gpio_ranges = 0x0
#endif
};

static inline pio_sm_config simple_pe_counter_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + simple_pe_counter_wrap_target, offset + simple_pe_counter_wrap);
    return c;
}

    static inline void simple_pe_counter_program_init(PIO pio, uint sm, uint offset, uint pin) {
        pio_sm_config c = simple_pe_counter_program_get_default_config(offset);
        // 入力ピン設定
        sm_config_set_in_pins(&c, pin);
        // GPIO設定
        pio_gpio_init(pio, pin);
        pio_sm_set_consecutive_pindirs(pio, sm, pin, 1, false);
        // プルダウン設定
        gpio_pull_down(pin);
        // ステートマシン初期化
        pio_sm_init(pio, sm, offset, &c);
        // IRQクリア
        pio_interrupt_clear(pio, 0);
        // ステートマシン開始
        pio_sm_set_enabled(pio, sm, true);
    }
    // シンプルなPE立ち下がりエッジハンドラ
    static void simple_pe_handler(void) {
        pio_interrupt_clear(pio0, 0);
        // 全割り込み禁止
        uint32_t saved_irq = save_and_disable_interrupts();
        // デバッグパルス出力
        // gpio_put(PIN_DBG_NEXT, 1);
        // busy_wait_us(1);
        // gpio_put(PIN_DBG_NEXT, 0);

        driveAH_Direct(columnBits[column_scan_line]);
   
        // 最終受信時刻を更新
        last_pe_time_us = time_us_32();
        pe_signal_active = true;
   
        // column_scan_lineを更新
        column_scan_line++;
        if (column_scan_line > 14) column_scan_line = 0;
        // 割り込みを元の状態に戻す
        restore_interrupts(saved_irq);
    }

    static inline void setup_simple_pe_counter(uint input_pin, uint debug_pin) {
        // デバッグピン初期化
        // gpio_init(debug_pin);
        // gpio_set_dir(debug_pin, GPIO_OUT);
        // gpio_put(debug_pin, 0);
        // PIOプログラムロード
        uint offset = pio_add_program(pio0, &simple_pe_counter_program);
        // ステートマシン初期化
        simple_pe_counter_program_init(pio0, 0, offset, input_pin);
        // 割り込みハンドラ設定
        irq_set_exclusive_handler(PIO0_IRQ_0, simple_pe_handler);
        irq_set_priority(PIO0_IRQ_0, 0x00);  // 0x00が最高優先度
        irq_set_enabled(PIO0_IRQ_0, true);
        pio_set_irq0_source_enabled(pio0, pis_interrupt0, true);
    }

#endif

